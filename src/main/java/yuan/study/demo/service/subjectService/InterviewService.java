package yuan.study.demo.service.subjectService;


public interface InterviewService {

    /**
     * 示例 1：
     * 输入: s = "leetcode"
     * 输出: false
     *
     * 示例 2：
     * 输入: s = "abc"
     * 输出: true
     *
     * 限制：
     * 0 <= len(s) <= 100
     * s[i]仅包含小写字母
     * 如果你不使用额外的数据结构，会很加分。
     */
    String isUnique();

    /**
     * 给定两个由小写字母组成的字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
     *
     * 示例 1：
     * 输入: s1 = "abc", s2 = "bca"
     * 输出: true
     *
     * 示例 2：
     * 输入: s1 = "abc", s2 = "bad"
     * 输出: false
     *
     * 说明：
     * 0 <= len(s1) <= 100
     * 0 <= len(s2) <= 100
     */
    String checkPermutation();

    /**
     * URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）
     *
     * 示例 1：
     * 输入："Mr John Smith    ", 13
     * 输出："Mr%20John%20Smith"
     *
     * 示例 2：
     * 输入："               ", 5
     * 输出："%20%20%20%20%20"
     *
     * 提示：
     * 字符串长度在 [0, 500000] 范围内。
     */
    String replaceSpaces();

    /**
     * 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
     *
     * 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
     *
     * 回文串不一定是字典当中的单词。
     *
     * 示例1：
     * 输入："tactcoa"
     * 输出：true（排列有"tacocat"、"atcocta"，等等）
     */
    String canPermutePalindrome();

    /**
     * 字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
     *
     * 示例 1：
     * 输入：
     * first = "pale"
     * second = "ple"
     * 输出：True
     *
     * 示例 2：
     * 输入：
     * first = "pales"
     * second = "pal"
     * 输出：False
     */
    String oneEditAway();

    /**
     * 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
     *
     * 示例 1：
     * 输入："aabcccccaaa"
     * 输出："a2b1c5a3"
     *
     * 示例 2：
     * 输入："abbccd"
     * 输出："abbccd"
     * 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
     *
     * 提示：
     * 字符串长度在 [0, 50000] 范围内。
     */
    String compressString();

    /**
     * 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
     *
     * 示例 1：
     *  输入：s1 = "waterbottle", s2 = "erbottlewat"
     *  输出：True
     *
     * 示例 2：
     *  输入：s1 = "aa", s2 = "aba"
     *  输出：False
     *
     * 提示：
     * 字符串长度在[0, 100000]范围内。
     *
     * 说明:
     * 你能只调用一次检查子串的方法吗？
     */
    String isFlipedString();

    /**
     * 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
     *
     * 示例1：
     *  输入：[1, 2, 3, 3, 2, 1]
     *  输出：[1, 2, 3]
     *
     * 示例2：
     *  输入：[1, 1, 1, 1, 2]
     *  输出：[1, 2]
     *
     * 提示：
     * 链表长度在[0, 20000]范围内。
     * 链表元素在[0, 20000]范围内。
     *
     * 进阶：
     * 如果不得使用临时缓冲区，该怎么解决？
     */
    String removeDuplicateNodes();

    /**
     * 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
     * 注意：本题相对原题稍作改动
     *
     * 示例：
     * 输入： 1->2->3->4->5 和 k = 2
     * 输出： 4
     *
     * 说明：
     * 给定的 k 保证是有效的。
     */
    String kthToLast();

    /**
     * 若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。
     * 假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。
     * 例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f
     *
     * 示例：
     * 输入：节点 5 （位于单向链表 4->5->1->9 中）
     * 输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9
     */
    String deleteNode();

    /**
     * 给定两个用链表表示的整数，每个节点包含一个数位。
     * 这些数位是反向存放的，也就是个位排在链表首部。
     * 编写函数对这两个整数求和，并用链表形式返回结果。
     *
     * 示例：
     * 输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
     * 输出：2 -> 1 -> 9，即912
     * 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
     *
     * 示例：
     * 输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
     * 输出：9 -> 1 -> 2，即912
     */
    String addTwoNumbers();

    /**
     * 编写一个函数，检查输入的链表是否是回文的。
     *
     * 示例 1：
     * 输入： 1->2
     * 输出： false
     *
     * 示例 2：
     * 输入： 1->2->2->1
     * 输出： true
     *
     * 进阶：
     * 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
     */
    String isPalindrome();

    /**
     * 三合一。描述如何只用一个数组来实现三个栈。
     * 你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。
     * 构造函数会传入一个stackSize参数，代表每个栈的大小。
     *
     * 示例 1：
     *  输入：
     * ["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]
     * [[1], [0, 1], [0, 2], [0], [0], [0], [0]]
     *  输出：
     * [null, null, null, 1, -1, -1, true]
     * 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。
     *
     * 示例 2：
     *  输入：
     * ["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"]
     * [[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]
     *  输出：
     * [null, null, null, null, 2, 1, -1, -1]
     *
     * 提示：
     * 0 <= stackNum <= 2
     */
    String tripleInOne();

    /**
     * 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。
     * 当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.
     *
     * 示例 1：
     *  输入：
     * ["StackOfPlates", "push", "push", "popAt", "pop", "pop"]
     * [[1], [1], [2], [1], [], []]
     *  输出：
     * [null, null, null, 2, 1, -1]
     *
     * 示例 2：
     *  输入：
     * ["StackOfPlates", "push", "push", "push", "popAt", "popAt", "popAt"]
     * [[2], [1], [2], [3], [0], [0], [0]]
     *  输出：
     * [null, null, null, null, 2, 1, 3]
     */
    String stackOfPlates();

    /**
     * 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。
     *
     * 示例 1：
     *  输入：
     * ["SortedStack", "push", "push", "peek", "pop", "peek"]
     * [[], [1], [2], [], [], []]
     *  输出：
     * [null,null,null,1,null,2]
     *
     * 示例 2：
     *  输入：
     * ["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
     * [[], [], [], [1], [], []]
     *  输出：
     * [null,null,null,null,null,true]
     *
     * 提示：
     * 栈中的元素数目在[0, 5000]范围内。
     */
    String sortedStack();

    /**
     * 动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。
     * enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。
     * dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。
     *
     * 示例 1：
     *  输入：
     * ["AnimalShelf", "enqueue", "enqueue", "dequeueCat", "dequeueDog", "dequeueAny"]
     * [[], [[0, 0]], [[1, 0]], [], [], []]
     *  输出：
     * [null,null,null,[0,0],[-1,-1],[1,0]]
     *
     * 示例 2：
     *  输入：
     * ["AnimalShelf", "enqueue", "enqueue", "enqueue", "dequeueDog", "dequeueCat", "dequeueAny"]
     * [[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]
     *  输出：
     * [null,null,null,null,[2,1],[0,0],[1,0]]
     *
     * 说明:
     * 收纳所的最大容量为20000
     */
    String animalShelf();

    /**
     * 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。
     *
     * 示例 1：
     *  输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
     *  输出：true
     *
     * 示例 2：
     *  输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
     *  输出：true
     *
     * 提示：
     * 节点数量n在[0, 1e5]范围内。
     * 节点编号大于等于 0 小于 n。
     * 图中可能存在自环和平行边。
     */
    String findWhetherExistsPath();

    /**
     * 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。
     *
     * 示例：
     * 输入：[1,2,3,4,5,null,7,8]
     *
     *         1
     *        /  \
     *       2    3
     *      / \    \
     *     4   5    7
     *    /
     *   8
     * 输出：[[1],[2,3],[4,5,7],[8]]
     */
    String listOfDepth();

    /**
     * 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。
     * 如果指定节点没有对应的“下一个”节点，则返回null。
     *
     * 示例 1：
     * 输入：root = [2,1,3], p = 1
     *   2
     *  / \
     * 1   3
     * 输出：2
     *
     * 示例 2：
     * 输入：root = [5,3,6,2,4,null,null,1], p = 6
     *       5
     *      / \
     *     3   6
     *    / \
     *   2   4
     *  /
     * 1
     * 输出：null
     */
    String inorderSuccessor();

    /**
     * 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。
     * 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
     *     3
     *    / \
     *   5   1
     *  / \ / \
     * 6  2 0  8
     *   / \
     *  7   4
     * 示例 1：
     * 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
     * 输出：3
     * 解释：节点 5 和节点 1 的最近公共祖先是节点 3。
     *
     * 示例 2：
     * 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
     * 输出：5
     * 解释：节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
     *
     * 提示：
     * 所有节点的值都是唯一的。
     * p、q 为不同节点且均存在于给定的二叉树中。
     */
    String lowestCommonAncestor();

    /**
     * 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。
     *
     * 给定一个由不同节点组成的二叉搜索树 root，输出所有可能生成此树的数组。
     *
     * 示例 1：
     * 输入：root = [2,1,3]
     * 输出：[[2,1,3],[2,3,1]]
     * 解释：数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树
     *        2
     *       / \
     *      1   3
     *
     * 示例 2：
     * 输入：root = [4,1,null,null,3,2]
     * 输出：[[4,1,3,2]]
     *
     * 提示：
     * 二叉搜索树中的节点数在 [0, 1000] 的范围内
     * 1 <= 节点值 <= 106
     * 用例保证符合要求的数组数量不超过 5000
     */
    String BSTSequences();

    /**
     * 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。
     * 如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。
     * 注意：此题相对书上原题略有改动。
     *
     * 示例 1：
     *  输入：t1 = [1, 2, 3], t2 = [2]
     *  输出：true
     *
     * 示例 2：
     *  输入：t1 = [1, null, 2, 4], t2 = [3, 2]
     *  输出：false
     *
     * 提示：
     * 树的节点数目范围为 [0, 20000]。
     */
    String checkSubTree();

    /**
     * 给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i <= j，且从 0 位开始计算）。
     * 编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。
     * 题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。
     *
     * 示例 1：
     *  输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6
     *  输出：N = 1100(10001001100)
     *
     * 示例 2：
     *  输入：N = 0, M = 31(11111), i = 0, j = 4
     *  输出：N = 31(11111)
     */
    String insertBits();
}
