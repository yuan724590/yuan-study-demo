package yuan.study.demo.service.subjectService;


public interface InterviewService {

    /**
     * 示例 1：
     * 输入: s = "leetcode"
     * 输出: false
     *
     * 示例 2：
     * 输入: s = "abc"
     * 输出: true
     *
     * 限制：
     * 0 <= len(s) <= 100
     * s[i]仅包含小写字母
     * 如果你不使用额外的数据结构，会很加分。
     */
    String isUnique();

    /**
     * 给定两个由小写字母组成的字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
     *
     * 示例 1：
     * 输入: s1 = "abc", s2 = "bca"
     * 输出: true
     *
     * 示例 2：
     * 输入: s1 = "abc", s2 = "bad"
     * 输出: false
     *
     * 说明：
     * 0 <= len(s1) <= 100
     * 0 <= len(s2) <= 100
     */
    String checkPermutation();

    /**
     * URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）
     *
     * 示例 1：
     * 输入："Mr John Smith    ", 13
     * 输出："Mr%20John%20Smith"
     *
     * 示例 2：
     * 输入："               ", 5
     * 输出："%20%20%20%20%20"
     *
     * 提示：
     * 字符串长度在 [0, 500000] 范围内。
     */
    String replaceSpaces();

    /**
     * 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
     *
     * 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
     *
     * 回文串不一定是字典当中的单词。
     *
     * 示例1：
     * 输入："tactcoa"
     * 输出：true（排列有"tacocat"、"atcocta"，等等）
     */
    String canPermutePalindrome();

    /**
     * 字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
     *
     * 示例 1：
     * 输入：
     * first = "pale"
     * second = "ple"
     * 输出：True
     *
     * 示例 2：
     * 输入：
     * first = "pales"
     * second = "pal"
     * 输出：False
     */
    String oneEditAway();

    /**
     * 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
     *
     * 示例 1：
     * 输入："aabcccccaaa"
     * 输出："a2b1c5a3"
     *
     * 示例 2：
     * 输入："abbccd"
     * 输出："abbccd"
     * 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
     *
     * 提示：
     * 字符串长度在 [0, 50000] 范围内。
     */
    String compressString();

    /**
     * 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
     *
     * 示例 1：
     *  输入：s1 = "waterbottle", s2 = "erbottlewat"
     *  输出：True
     *
     * 示例 2：
     *  输入：s1 = "aa", s2 = "aba"
     *  输出：False
     *
     * 提示：
     * 字符串长度在[0, 100000]范围内。
     *
     * 说明:
     * 你能只调用一次检查子串的方法吗？
     */
    String isFlipedString();

    /**
     * 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
     *
     * 示例1：
     *  输入：[1, 2, 3, 3, 2, 1]
     *  输出：[1, 2, 3]
     *
     * 示例2：
     *  输入：[1, 1, 1, 1, 2]
     *  输出：[1, 2]
     *
     * 提示：
     * 链表长度在[0, 20000]范围内。
     * 链表元素在[0, 20000]范围内。
     *
     * 进阶：
     * 如果不得使用临时缓冲区，该怎么解决？
     */
    String removeDuplicateNodes();

    /**
     * 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
     * 注意：本题相对原题稍作改动
     *
     * 示例：
     * 输入： 1->2->3->4->5 和 k = 2
     * 输出： 4
     *
     * 说明：
     * 给定的 k 保证是有效的。
     */
    String kthToLast();

    /**
     * 若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。
     * 假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。
     * 例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f
     *
     * 示例：
     * 输入：节点 5 （位于单向链表 4->5->1->9 中）
     * 输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9
     */
    String deleteNode();

    /**
     * 给定两个用链表表示的整数，每个节点包含一个数位。
     * 这些数位是反向存放的，也就是个位排在链表首部。
     * 编写函数对这两个整数求和，并用链表形式返回结果。
     *
     * 示例：
     * 输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
     * 输出：2 -> 1 -> 9，即912
     * 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
     *
     * 示例：
     * 输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
     * 输出：9 -> 1 -> 2，即912
     */
    String addTwoNumbers();

    /**
     * 编写一个函数，检查输入的链表是否是回文的。
     *
     * 示例 1：
     * 输入： 1->2
     * 输出： false
     *
     * 示例 2：
     * 输入： 1->2->2->1
     * 输出： true
     *
     * 进阶：
     * 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
     */
    String isPalindrome();
}
